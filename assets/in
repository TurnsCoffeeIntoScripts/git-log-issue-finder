#!/bin/bash

# Force exit when a pipeline/single-command returns with non-zero status
set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

# for jq
PATH=/usr/local/bin:$PATH
TMPDIR=${TMPDIR:-/tmp}

# Payload
payload=$TMPDIR/gltf-request
cat > $payload <&0

# Extracting configurations from resource configuration
git_repo_name=$(jq -r '.source.git_repo_name // ""' < $payload)
tickets=$(jq -r '.source.tickets // ""' < $payload)
max_commit=$(jq -r '.source.maxCommit // ""' < $payload)

# If maxCommit if specified, then we append it to '--max-count' for the git log command.
# Otherwise it's left empty
if [[ ! -z max_commit ]]; then
    maxCommit = "--max-count=max_commit"
else
    maxCommit = ""
fi

# Set the destination for the cloned repo
destination=$git_repo_name

# If it already fetch new version otherwise exit with return code 1
if [[ -d $destination ]]; then
    cd $destination
    git fetch

    # Execute the git log with optionnal maxCommit
    log=$(git log --pretty=oneline max_commit)

    # Launch the Go exec 'gitLogTicketFinder'
    gltfResult=$(gitLogTicketFinder --tickets $tickets --content "$log")

    # Output the result to fd 3
    echo "${gltfResult}" >&3

    cd ../
else
    echo "Git repo $destination does not exist or could not be found"
    exit 1
fi