#!/bin/bash

# Force exit when a pipeline/single-command returns with non-zero status
set -e

exec 3>&1 # make stdout available as fd 3 for the result
exec 1>&2 # redirect all output to stderr for logging

# for jq
PATH=/usr/local/bin:$PATH
TMPDIR=${TMPDIR:-/tmp}

# Payload
payload=$TMPDIR/gltf-request
cat > $payload <&0

# Extracting configurations from resource configuration
uri=$(jq -r '.source.uri // ""' < $payload)
branch=$(jq -r '.source.branch // ""' < $payload)
tickets=$(jq -r '.source.tickets // ""' < $payload)
maxCommit=$(jq -r '.source.maxCommit // ""' < $payload)

# If maxCommit if specified, then we append it to '--max-count' for the git log command.
# Otherwise it's left empty
if [[ ! -z $maxCommit ]]; then
    maxCommit = "--max-count=$maxCommit"
else
    maxCommit = ""
fi

# Set the destination for the cloned repo
destination=$TMPDIR/gltf-repo-cache

# If it already exists remove it
if [[ -d $destination ]]; then
    rm -rf $destination
fi

# Execute the clone with:
#   branch parameter
#   tags flag
#   bare falg
git clone --bare $uri $destination --branch $branch --tags

# Execute the git log with optionnal maxCommit
cd $destination
log=$(git log --pretty=oneline $maxCommit)

# Launch the Go exec 'gitLogTicketFinder'
gltfResult=$(gitLogTicketFinder --tickets $tickets --content "$log")

# Output the result to fd 3
echo "${gltfResult}" >&3

cd ../